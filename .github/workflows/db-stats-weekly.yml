name: Database Stats Weekly Report

on:
  schedule:
    # 毎週月曜日の午前9時（JST）に実行
    # UTC時間で毎週日曜日の午後11時（23:00 UTC = 09:00 JST）
    - cron: '0 23 * * 0'
  workflow_dispatch: # 手動実行も可能にする

jobs:
  db-stats:
    name: Collect Database Statistics
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Create .env.local file
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE: ${{ secrets.SUPABASE_SERVICE_ROLE }}
        run: |
          cat > .env.local << EOF
          NEXT_PUBLIC_SUPABASE_URL=${NEXT_PUBLIC_SUPABASE_URL}
          SUPABASE_SERVICE_ROLE=${SUPABASE_SERVICE_ROLE}
          EOF

      - name: Run database stats
        id: db-stats
        run: |
          set +e
          OUTPUT=$(npm run db:stats 2>&1)
          EXIT_CODE=$?
          set -e
          echo "exit_code=${EXIT_CODE}" >> $GITHUB_OUTPUT
          echo "output<<EOF" >> $GITHUB_OUTPUT
          echo "$OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          # 出力をファイルにも保存（デバッグ用）
          echo "$OUTPUT" > db-stats-output.txt
        continue-on-error: true

      - name: Send webhook notification
        if: always()
        run: |
          # Node.jsでJSONペイロードを作成して送信
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');
          const http = require('http');
          const { URL } = require('url');

          const output = fs.readFileSync('db-stats-output.txt', 'utf-8');
          const timestamp = new Date().toISOString();

          const payload = {
            event: 'db_stats_weekly_report',
            status: process.env.STATUS,
            timestamp: timestamp,
            repository: process.env.GITHUB_REPOSITORY,
            workflow_run_id: process.env.GITHUB_RUN_ID,
            workflow_run_url: `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`,
            output: output
          };

          const webhookUrl = process.env.DB_STATS_WEBHOOK_URL;
          if (!webhookUrl) {
            console.error('DB_STATS_WEBHOOK_URL is not set');
            process.exit(1);
          }

          const url = new URL(webhookUrl);
          const client = url.protocol === 'https:' ? https : http;
          const postData = JSON.stringify(payload);

          const options = {
            hostname: url.hostname,
            port: url.port || (url.protocol === 'https:' ? 443 : 80),
            path: url.pathname + url.search,
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Content-Length': Buffer.byteLength(postData)
            }
          };

          const req = client.request(options, (res) => {
            let data = '';
            res.on('data', (chunk) => { data += chunk; });
            res.on('end', () => {
              if (res.statusCode >= 200 && res.statusCode < 300) {
                console.log('Webhook notification sent successfully');
                process.exit(0);
              } else {
                console.error(`Webhook notification failed with status ${res.statusCode}: ${data}`);
                process.exit(1);
              }
            });
          });

          req.on('error', (error) => {
            console.error('Webhook notification error:', error.message);
            process.exit(1);
          });

          req.write(postData);
          req.end();
          EOF

        env:
          STATUS: ${{ steps.db-stats.outputs.exit_code == '0' && 'success' || 'failure' }}
          DB_STATS_WEBHOOK_URL: ${{ secrets.DB_STATS_WEBHOOK_URL }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
