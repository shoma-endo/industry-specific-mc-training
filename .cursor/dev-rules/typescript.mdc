---
description: TypeScript 型定義とコーディング規約
globs:
alwaysApply: true
---

あなたは TypeScript（v5.9.3）を用いた型安全なコーディングのエキスパートです。Next.js（v15.5.12）、React（v19.2.3）を使ったモダンなアプリケーションにおいて、strict モードを活用し、保守性と可読性の高いコードを実装してください。

## 主な責任

- TypeScript strict モードを前提とした型安全なコードを記述してください。
- `interface` を優先し、型定義の一貫性を保ってください。
- 共有型は `src/types/` に集約し、フロント・サーバー双方で再利用してください。
- Zod スキーマと TypeScript 型を連携させ、ランタイム検証と型安全性を両立してください。

## TypeScript strict モード

### 有効化されている strict オプション

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true
  }
}
```

### strict モードの遵守

- `any` 型の使用は禁止。やむを得ない場合は `unknown` を使用し、型ガードで絞り込む。
- `null` と `undefined` を明示的に扱い、オプショナルチェーン（`?.`）や Nullish Coalescing（`??`）を活用。
- 関数の引数と戻り値の型は必ず明示的に定義。
- クラスのプロパティは初期化または `!` 演算子で明示的に非 null を保証。

## interface vs type

### interface を優先使用

```typescript
// ✅ Good: オブジェクトの形状は interface で定義
interface User {
  id: string;
  name: string;
  email: string;
  role: 'trial' | 'paid' | 'admin' | 'unavailable';
}

interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}
```

### type を使用するケース

```typescript
// ✅ Good: Union 型、Intersection 型、Mapped Types は type で定義
type UserRole = 'trial' | 'paid' | 'admin' | 'unavailable';

type Nullable<T> = T | null;

type ReadonlyUser = Readonly<User>;

// ✅ Good: 関数型は type で定義
type MessageHandler = (message: ChatMessage) => void;

// ✅ Good: Conditional Types
type NonNullableFields<T> = {
  [P in keyof T]: NonNullable<T[P]>;
};
```

### interface の拡張

```typescript
// ✅ Good: interface は extends で拡張可能
interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

interface User extends BaseEntity {
  name: string;
  email: string;
}

interface ChatSession extends BaseEntity {
  userId: string;
  title: string;
}
```

## 共有型の配置ルール

### src/types/ への集約

- すべての共有型定義は `src/types/` に配置
- ファイル名は kebab-case（例：`chat.ts`, `user.ts`, `wordpress.ts`）
- ドメインごとにファイルを分割（1ファイル = 1ドメイン）

### 型定義ファイルの構造

```typescript
// src/types/chat.ts
export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export interface ChatSession {
  id: string;
  userId: string;
  title: string;
  messages: ChatMessage[];
  createdAt: Date;
}

export type ChatErrorCode =
  | 'UNAUTHORIZED'
  | 'RATE_LIMIT_EXCEEDED'
  | 'INVALID_INPUT'
  | 'INTERNAL_ERROR';

export interface ChatError {
  code: ChatErrorCode;
  message: string;
  details?: unknown;
}
```

### 環境変数の型定義

```typescript
// src/types/env.ts
export interface Env {
  // Supabase
  NEXT_PUBLIC_SUPABASE_URL: string;
  NEXT_PUBLIC_SUPABASE_ANON_KEY: string;
  SUPABASE_SERVICE_ROLE_KEY: string;

  // LINE LIFF
  NEXT_PUBLIC_LIFF_ID: string;
  LINE_CHANNEL_SECRET: string;

  // Anthropic
  ANTHROPIC_API_KEY: string;

  // Stripe
  STRIPE_ENABLED: string;
  STRIPE_SECRET_KEY?: string;
  STRIPE_PUBLISHABLE_KEY?: string;
}

declare global {
  namespace NodeJS {
    interface ProcessEnv extends Env {}
  }
}
```

## Zod スキーマとの連携

### Zod スキーマから TypeScript 型を生成

```typescript
// src/server/schemas/brief.schema.ts
import { z } from 'zod';

export const briefSchema = z.object({
  what: z.string().min(1, '商品・サービスは必須です'),
  who: z.string().min(1, 'ターゲット顧客は必須です'),
  why: z.string().optional(),
  where: z.string().optional(),
  when: z.string().optional(),
  how: z.string().optional(),
  howMuch: z.string().optional(),
});

// Zod スキーマから TypeScript 型を推論
export type BriefInput = z.infer<typeof briefSchema>;
```

### Server Actions での Zod 検証

```typescript
// src/server/actions/brief.actions.ts
'use server';

import { briefSchema, type BriefInput } from '@/server/schemas/brief.schema';

export async function saveBrief(data: unknown): Promise<{ success: boolean; error?: string }> {
  // Zod でランタイム検証
  const result = briefSchema.safeParse(data);

  if (!result.success) {
    return {
      success: false,
      error: result.error.errors.map(e => e.message).join(', '),
    };
  }

  // result.data は BriefInput 型として型安全
  const brief: BriefInput = result.data;

  // データベースに保存...
}
```

## 型ガードとユーティリティ型

### 型ガード関数

```typescript
// src/lib/type-guards.ts

export function isUserRole(value: unknown): value is UserRole {
  return typeof value === 'string' && ['trial', 'paid', 'admin', 'unavailable'].includes(value);
}

export function isChatMessage(value: unknown): value is ChatMessage {
  return (
    typeof value === 'object' &&
    value !== null &&
    'id' in value &&
    'role' in value &&
    'content' in value &&
    typeof (value as ChatMessage).id === 'string'
  );
}

// unknown からの型絞り込み
function processMessage(data: unknown) {
  if (isChatMessage(data)) {
    // data は ChatMessage 型として扱える
    console.log(data.content);
  }
}
```

### ユーティリティ型の活用

```typescript
// Partial<T> - すべてのプロパティをオプショナルに
type PartialUser = Partial<User>;

// Required<T> - すべてのプロパティを必須に
type RequiredConfig = Required<Config>;

// Pick<T, K> - 特定のプロパティのみを抽出
type UserCredentials = Pick<User, 'email' | 'password'>;

// Omit<T, K> - 特定のプロパティを除外
type PublicUser = Omit<User, 'password' | 'email'>;

// Record<K, T> - キーと値の型を指定
type UserRolePermissions = Record<UserRole, string[]>;

// NonNullable<T> - null と undefined を除外
type DefinedValue = NonNullable<string | null | undefined>; // string
```

## エラーハンドリングと型安全性

### Result 型パターン

```typescript
// src/types/result.ts
export type Result<T, E = string> = { success: true; data: T } | { success: false; error: E };

// 使用例
export async function fetchUser(id: string): Promise<Result<User>> {
  try {
    const user = await db.user.findUnique({ where: { id } });
    if (!user) {
      return { success: false, error: 'User not found' };
    }
    return { success: true, data: user };
  } catch (error) {
    return { success: false, error: 'Database error' };
  }
}

// 呼び出し側
const result = await fetchUser('123');
if (result.success) {
  console.log(result.data.name); // result.data は User 型
} else {
  console.error(result.error); // result.error は string 型
}
```

## コードスタイルと命名規則

### 型・インターフェース名

- **PascalCase** を使用：`User`, `ChatMessage`, `ChatSession`
- 説明的な名前を付ける：`UserCreateInput`, `ChatMessageResponse`

### 型エイリアス名

- **PascalCase** を使用：`UserRole`, `ChatErrorCode`
- Union 型は具体的な名前を付ける：`ApiResponse`, `AuthResult`

### ジェネリック型パラメータ

- 単一文字（`T`, `K`, `V`）または説明的な名前（`TData`, `TError`）
- 複数のパラメータがある場合は説明的な名前を優先

```typescript
// ✅ Good
interface ApiResponse<TData, TError = string> {
  data?: TData;
  error?: TError;
}

// ❌ Bad
interface ApiResponse<A, B> {
  data?: A;
  error?: B;
}
```

## プロジェクト固有のルール

- **型ファイルの配置**: `src/types/` に kebab-case で配置（例：`chat.ts`, `analytics.ts`）
- **interface 優先**: オブジェクト型は必ず `interface` で定義
- **Zod スキーマの配置**: `src/server/schemas/` に配置し、`z.infer` で型を生成
- **共有型の再利用**: フロント・サーバーで同じ型を使用し、重複定義を避ける
- **型安全な Result パターン**: Server Actions の戻り値は `Result<T>` 型を使用

## 避けるべきパターン

### ❌ Bad: any の使用

```typescript
// ❌ Bad
function processData(data: any) {
  return data.value;
}

// ✅ Good
function processData(data: unknown) {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return (data as { value: string }).value;
  }
  throw new Error('Invalid data format');
}
```

### ❌ Bad: type でオブジェクト型を定義

```typescript
// ❌ Bad
type User = {
  id: string;
  name: string;
};

// ✅ Good
interface User {
  id: string;
  name: string;
}
```

### ❌ Bad: 暗黙的な any

```typescript
// ❌ Bad
function handleEvent(event) {
  // event は暗黙的に any
  console.log(event.target.value);
}

// ✅ Good
function handleEvent(event: React.ChangeEvent<HTMLInputElement>) {
  console.log(event.target.value);
}
```

TypeScript の公式ドキュメントと最新のベストプラクティスに常に従い、型安全で保守性の高いコードを実装してください。
