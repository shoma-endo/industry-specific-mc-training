---
description: Google Search Console 連携機能の実装ルール
globs:
alwaysApply: true
---
あなたは Google Search Console（GSC）API を用いたデータ連携機能の実装におけるエキスパートです。Next.js（v15.4.7）、React（v19.0.0）、TypeScript（v5.9）を使ったモダンなアプリケーションにおいて、GSC データの取得・保存・分析を安全かつ効率的に実装してください。

## 主な責任

- Google Search Console API（Search Analytics API）を用いたデータ取得を実装してください。
- OAuth 2.0 認証フローを実装し、ユーザーの GSC アカウントに安全にアクセスしてください。
- プロパティ選択、データインポート、定期的な更新機能を実装してください。
- API レート制限を考慮し、エラーハンドリングとリトライロジックを適切に実装してください。

## サーバー側の実装ルール

- Google Cloud Console の認証情報はすべて環境変数で管理し、`.env.local` でのみ定義してください。
- **すべての GSC 操作は Server Actions（`src/server/actions/gscSetup.actions.ts`）経由に統一**してください。
- OAuth トークンは Supabase の `users` テーブルの `gsc_credentials` カラムに暗号化して保存してください。
- API Routes は `/api/gsc/oauth-init` と `/api/gsc/oauth-callback` に配置してください。

## OAuth 2.0 認証フロー

### 1. OAuth 初期化（`/api/gsc/oauth-init`）
```typescript
// OAuth URL を生成してリダイレクト
const oauth2Client = new google.auth.OAuth2(
  process.env.GOOGLE_CLIENT_ID,
  process.env.GOOGLE_CLIENT_SECRET,
  `${process.env.NEXT_PUBLIC_APP_URL}/api/gsc/oauth-callback`
);

const authUrl = oauth2Client.generateAuthUrl({
  access_type: 'offline',
  scope: ['https://www.googleapis.com/auth/webmasters.readonly'],
  state: userId, // CSRF 対策
});

return Response.redirect(authUrl);
```

### 2. OAuth コールバック（`/api/gsc/oauth-callback`）
```typescript
// 認可コードを受け取り、アクセストークンを取得
const { code, state } = searchParams;

const { tokens } = await oauth2Client.getToken(code);

// トークンを Supabase に保存
await supabase
  .from('users')
  .update({
    gsc_credentials: JSON.stringify(tokens),
    gsc_connected: true,
  })
  .eq('id', state);
```

### 3. トークンリフレッシュ
```typescript
// アクセストークンの有効期限をチェックし、必要に応じてリフレッシュ
const credentials = JSON.parse(user.gsc_credentials);

if (credentials.expiry_date && Date.now() >= credentials.expiry_date) {
  oauth2Client.setCredentials(credentials);
  const { credentials: newCredentials } = await oauth2Client.refreshAccessToken();

  // 新しいトークンを保存
  await supabase
    .from('users')
    .update({ gsc_credentials: JSON.stringify(newCredentials) })
    .eq('id', userId);
}
```

## GSC データ取得パターン

### プロパティ一覧の取得（`fetchGscProperties`）
```typescript
'use server';

export async function fetchGscProperties(): Promise<Result<GscProperty[]>> {
  const user = await getCurrentUser();

  if (!user?.gsc_credentials) {
    return { success: false, error: 'GSC 連携が必要です' };
  }

  const oauth2Client = new google.auth.OAuth2();
  oauth2Client.setCredentials(JSON.parse(user.gsc_credentials));

  const webmasters = google.webmasters({ version: 'v3', auth: oauth2Client });

  try {
    const response = await webmasters.sites.list();
    const properties = response.data.siteEntry?.map(site => ({
      siteUrl: site.siteUrl,
      permissionLevel: site.permissionLevel,
    })) || [];

    return { success: true, data: properties };
  } catch (error) {
    return { success: false, error: 'プロパティ取得に失敗しました' };
  }
}
```

### Search Analytics データの取得
```typescript
export async function fetchSearchAnalytics(
  siteUrl: string,
  startDate: string,
  endDate: string
): Promise<Result<GscAnalyticsData>> {
  const oauth2Client = await getAuthenticatedClient();
  const webmasters = google.webmasters({ version: 'v3', auth: oauth2Client });

  try {
    const response = await webmasters.searchanalytics.query({
      siteUrl: siteUrl,
      requestBody: {
        startDate: startDate, // YYYY-MM-DD
        endDate: endDate,
        dimensions: ['page', 'query'],
        rowLimit: 25000,
        dataState: 'final', // 確定データのみ
      },
    });

    return { success: true, data: response.data };
  } catch (error) {
    return { success: false, error: 'データ取得に失敗しました' };
  }
}
```

## データ保存パターン

### Supabase へのデータ保存
```typescript
export async function saveGscData(
  siteUrl: string,
  data: GscAnalyticsRow[]
): Promise<Result<void>> {
  const supabase = await getSupabaseClient();

  try {
    // 既存データを削除（上書き保存）
    await supabase
      .from('gsc_data')
      .delete()
      .eq('site_url', siteUrl)
      .gte('date', startDate)
      .lte('date', endDate);

    // 新しいデータを挿入
    const { error } = await supabase
      .from('gsc_data')
      .insert(
        data.map(row => ({
          site_url: siteUrl,
          page: row.keys[0],
          query: row.keys[1],
          clicks: row.clicks,
          impressions: row.impressions,
          ctr: row.ctr,
          position: row.position,
          date: row.date,
        }))
      );

    if (error) {
      return { success: false, error: 'データ保存に失敗しました' };
    }

    return { success: true, data: undefined };
  } catch (error) {
    return { success: false, error: 'データベースエラー' };
  }
}
```

## API レート制限対策

### レート制限の理解
- **Search Analytics API**: 1日あたり 1,000 リクエスト
- **Sites API**: 1日あたり 200 リクエスト
- **同時リクエスト数**: 最大 10 リクエスト

### Exponential Backoff リトライ
```typescript
async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3
): Promise<T> {
  let lastError: Error;

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;

      // レート制限エラー（429）の場合はリトライ
      if ((error as any).code === 429) {
        const waitTime = Math.pow(2, i) * 1000; // 1秒, 2秒, 4秒...
        await new Promise(resolve => setTimeout(resolve, waitTime));
        continue;
      }

      // その他のエラーは即座に throw
      throw error;
    }
  }

  throw lastError!;
}

// 使用例
const data = await retryWithBackoff(() =>
  webmasters.searchanalytics.query({ siteUrl, requestBody })
);
```

### バッチ処理とスロットリング
```typescript
// 大量のデータを取得する場合は日付を分割
async function fetchDataInBatches(
  siteUrl: string,
  startDate: Date,
  endDate: Date
) {
  const dates = generateDateRange(startDate, endDate, 7); // 7日ごとに分割

  const results = [];
  for (const { start, end } of dates) {
    const result = await fetchSearchAnalytics(siteUrl, start, end);
    results.push(result);

    // レート制限を避けるため、各リクエスト間に待機
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  return results;
}
```

## エラーハンドリング

### GSC API エラーの処理
```typescript
try {
  const response = await webmasters.searchanalytics.query({ siteUrl, requestBody });
} catch (error: any) {
  // 認証エラー（401）
  if (error.code === 401) {
    return { success: false, error: '認証が必要です。再度連携してください。' };
  }

  // 権限エラー（403）
  if (error.code === 403) {
    return { success: false, error: 'このプロパティへのアクセス権限がありません。' };
  }

  // レート制限エラー（429）
  if (error.code === 429) {
    return { success: false, error: 'API 制限に達しました。しばらく待ってから再試行してください。' };
  }

  // その他のエラー
  return { success: false, error: 'データ取得に失敗しました。' };
}
```

## セキュリティ

- OAuth トークンをクライアントに露出しないでください。
- すべての GSC API 呼び出しはサーバーサイド（Server Actions）で行ってください。
- トークンは Supabase に暗号化して保存してください（`gsc_credentials` カラム）。
- OAuth の `state` パラメータで CSRF 攻撃を防いでください。
- スコープは最小限に制限してください（`webmasters.readonly`）。

## データ管理

### データの鮮度管理
```typescript
// 最終取得日時を記録
await supabase
  .from('users')
  .update({
    gsc_last_import: new Date().toISOString(),
  })
  .eq('id', userId);

// データが古い場合は再取得を促す
const lastImport = new Date(user.gsc_last_import);
const daysSinceImport = (Date.now() - lastImport.getTime()) / (1000 * 60 * 60 * 24);

if (daysSinceImport > 7) {
  return { success: false, error: 'データが古くなっています。再取得してください。' };
}
```

### データの整合性
- データインポート時は既存データを削除してから挿入（上書き保存）
- トランザクションを使用してデータの一貫性を保証
- 重複データを防ぐため、ユニーク制約を設定

## コードスタイルと技術要件

- すべて TypeScript strict モードで記述してください。
- `interface` を優先使用し、`type` は `interface` で表現できない場合に限定してください。
- 関数は早期 return を使用して可読性を高めてください。
- **ファイル命名**:
  - Actions: `camelCase + .actions.ts`（`gscSetup.actions.ts`）
  - API Routes: `kebab-case`（`oauth-init`, `oauth-callback`）
  - Types: `kebab-case.ts`（`gsc.ts`）

## パフォーマンスとユーザー体験

- データ取得中はローディング状態を表示してください。
- 大量データの取得は進捗表示を実装してください。
- エラー発生時は具体的なエラーメッセージとリトライオプションを提供してください。
- バックグラウンドでの定期的なデータ更新を実装してください。

## プロジェクト固有のルール

- **Server Actions の統一**: すべての GSC 操作は `gscSetup.actions.ts` を経由してください。
- **トークン管理**: Supabase の `users.gsc_credentials` に暗号化して保存してください。
- **データ保存**: `gsc_data` テーブルに保存し、Analytics 機能から参照してください。
- **UI 統合**: `GscSetupClient` コンポーネントと `SetupDashboard` から呼び出してください。

## トラブルシューティング

### よくある問題と対処法

1. **OAuth 認証エラー**
   - リダイレクト URI が Google Cloud Console の設定と一致しているか確認
   - スコープが正しく設定されているか確認（`webmasters.readonly`）

2. **トークンリフレッシュ失敗**
   - `access_type: 'offline'` が設定されているか確認
   - リフレッシュトークンが保存されているか確認

3. **API レート制限エラー（429）**
   - Exponential Backoff でリトライ
   - バッチ処理間に適切な待機時間を設定

4. **データ取得失敗**
   - プロパティ URL が正しいか確認（`sc-domain:example.com` 形式）
   - 日付範囲が有効か確認（過去 16 ヶ月以内）
   - データが存在するか確認（新しいサイトはデータがない場合あり）

Google Search Console API の公式ドキュメントと最新のベストプラクティスに常に従い、安全で信頼性の高い GSC 連携機能を実装してください。
